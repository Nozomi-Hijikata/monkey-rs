use std::str::FromStr;
use crate::ast::{Stmt, Expr, Opcode};

grammar;

// non-terminals(Statements)
Stmts: Vec<Stmt> = {
    (Stmt)* => <>.into_iter().collect(),
};

pub Stmt: Stmt = {
  LetStmt,
  ReturnStmt,
  ExprStmt,
  BlockStmt,
};


LetStmt: Stmt = {
    "let" <name:Identifier> "=" <value:Expr> ";" => Stmt::LetStmt{<>},
};

// TODO: セミコロンを除外してもparseできるようにする
ReturnStmt: Stmt = {
    "return" <return_value:Expr> ";" => Stmt::ReturnStmt{ <> },
};

// TODO: セミコロンを除外してもparseできるようにする
ExprStmt: Stmt = {
    <expression:Expr> ";" => Stmt::ExprStmt{ <> },
};

BlockStmt: Stmt = {
    "{" <statements:Stmts> "}" => Stmt::BlockStmt { <> },
}

// non-terminals(Expression)
pub Expr: Box<Expr> = {
  #[precedence(level="0")]
  Term,
  #[precedence(level="1")] #[assoc(side="left")] // 左結合
  <left:Expr> <operator:FactorOp> <right:Expr> => Box::new(Expr::InfixOp{ <> }),
  #[precedence(level="2")] #[assoc(side="left")]
  <left:Expr> <operator:ExprOp> <right:Expr> => Box::new(Expr::InfixOp{ <> }),
  #[precedence(level="3")]
  IfExpr,
};

IfExpr: Box<Expr> = {
    "if" "(" <condition:Expr> ")" <consequence:BlockStmt> "else" <alternative:BlockStmt>
      => Box::new(Expr::IfExpr { condition: condition, consequence: consequence, alternative: Some(alternative) }),
    "if" "(" <condition:Expr> ")" <consequence:BlockStmt>
      =>Box::new(Expr::IfExpr { condition: condition, consequence: consequence, alternative: None }),
};

PrefixExpr: Box<Expr> = {
    <operator:PrefixOp> <right:Term> => Box::new(Expr::PrefixOp{ <> }),
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
    Identifier => Box::new(Expr::Identifier(<>)),
    Bool => Box::new(Expr::Boolean(<>)),
    PrefixExpr,
    "(" <Expr> ")",
};

// precedence of terminals
match {
    "true",
    "false",
    "let",
    "return",
    "if",
    "else",
} else {
    r"[a-zA-Z_][a-zA-Z0-9_]*",
    _
}

// terminals
Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string()
};

Bool: bool = {
    "true" => true,
    "false" => false
};


ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

PrefixOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
    "!" => Opcode::Bang,
};

