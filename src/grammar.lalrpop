use std::str::FromStr;
use crate::ast::{Stmt, Expr, Opcode};

grammar;

// non-terminals(Statements)
pub Stmt: Stmt = {
  LetStmt,
  ReturnStmt,
  ExprStmt,
};

LetStmt: Stmt = {
    "let" <name:Identifier> "=" <value:Expr> ";" => Stmt::LetStmt{<>},
};

ReturnStmt: Stmt = {
    "return" <return_value:Expr> ";" => Stmt::ReturnStmt{ <> },
};

ExprStmt: Stmt = {
    <expression:Expr> ";" => Stmt::ExprStmt{ <> },
};

// non-terminals(Expression)
pub Expr: Box<Expr> = {
  <left:Expr> <operator:ExprOp> <right:Factor> => Box::new(Expr::InfixOp{ <> }),
  Factor,
};


Factor: Box<Expr> = {
    <left:Factor> <operator:FactorOp> <right:Term> => Box::new(Expr::InfixOp{ <> }),
    Term,
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
    Identifier => Box::new(Expr::Identifier(<>)),
    Bool => Box::new(Expr::Boolean(<>)),
    <operator:PrefixOp> <right:Term> => Box::new(Expr::PrefixOp{ <> }),
    "(" <Expr> ")",
};

// precedence of terminals
match {
    "true",
    "false",
    "let",
    "return"
} else {
    r"[a-zA-Z_][a-zA-Z0-9_]*",
    _
}

// terminals
Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string()
};

Bool: bool = {
    "true" => true,
    "false" => false
};


ExprOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

FactorOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

PrefixOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
    "!" => Opcode::Bang,
};

