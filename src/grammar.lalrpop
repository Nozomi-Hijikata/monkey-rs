use std::str::FromStr;
use crate::ast::{Stmt, Expr, Opcode};

grammar;

// non-terminals(Statements)
Stmts: Vec<Stmt> = {
    (Stmt)* => <>.into_iter().collect(),
};

pub Stmt: Stmt = {
  LetStmt,
  ReturnStmt,
  ExprStmt,
  BlockStmt,
};


LetStmt: Stmt = {
    "let" <name:Identifier> "=" <value:Expr> ";" => Stmt::LetStmt{<>},
};

ReturnStmt: Stmt = {
    "return" <return_value:Expr> ";" => Stmt::ReturnStmt{ <> },
};

ExprStmt: Stmt = {
    <expression:Expr> ";" => Stmt::ExprStmt{ <> },
};

BlockStmt: Stmt = {
    "{" <statements:Stmts> "}" => Stmt::BlockStmt { <> },
}

// non-terminals(Expression)
pub Expr: Box<Expr> = {
  #[precedence(level="0")]
  Term,
  // 同じ優先度の場合は左結合
  #[precedence(level="1")] #[assoc(side="left")] // 1: 乗算除算
  <left:Expr> <operator:ProductOp> <right:Expr> => Box::new(Expr::InfixOp{ <> }),
  #[precedence(level="2")] #[assoc(side="left")] // 2: 加算減算
  <left:Expr> <operator:SumOp> <right:Expr> => Box::new(Expr::InfixOp{ <> }),
  #[precedence(level="3")] #[assoc(side="left")] // 3: 比較演算子
  <left:Expr> <operator:LessGreaterOp> <right:Expr> => Box::new(Expr::InfixOp{ <> }),
  #[precedence(level="4")] #[assoc(side="left")] // 4: 等価演算子
  <left:Expr> <operator:EqualsOp> <right:Expr> => Box::new(Expr::InfixOp{ <> }),
  #[precedence(level="5")]
  IfExpr,
  FuncLit,
};

IfExpr: Box<Expr> = {
    "if" "(" <condition:Expr> ")" <consequence:BlockStmt> "else" <alternative:BlockStmt>
      => Box::new(Expr::IfExpr { condition: condition, consequence: consequence, alternative: Some(alternative) }),
    "if" "(" <condition:Expr> ")" <consequence:BlockStmt>
      =>Box::new(Expr::IfExpr { condition: condition, consequence: consequence, alternative: None }),
};

FuncLit: Box<Expr> = {
    "fn" "(" <parameters:Params> ")" <body:BlockStmt> => Box::new(Expr::FuncLit{ parameters: parameters, body: body }),
};

Params: Vec<String> = Comma<Identifier>;

Comma<T>: Vec<T> = {
    <mut v:(<T> ",")*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

Term: Box<Expr> = {
    Num => Box::new(Expr::Number(<>)),
    Identifier => Box::new(Expr::Identifier(<>)),
    Bool => Box::new(Expr::Boolean(<>)),
    <operator:PrefixOp> <right:Term> => Box::new(Expr::PrefixOp{ <> }),
    "(" <Expr> ")",
};

// precedence of terminals
match {
    "true",
    "false",
    "let",
    "return",
    "if",
    "else",
    "fn",
} else {
    r"[a-zA-Z_][a-zA-Z0-9_]*",
    _
}

// terminals
Num: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
};

Identifier: String = {
    r"[a-zA-Z_][a-zA-Z0-9_]*" => <>.to_string()
};

Bool: bool = {
    "true" => true,
    "false" => false
};

SumOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
};

ProductOp: Opcode = {
    "*" => Opcode::Mul,
    "/" => Opcode::Div,
};

PrefixOp: Opcode = {
    "+" => Opcode::Add,
    "-" => Opcode::Sub,
    "!" => Opcode::Bang,
};

EqualsOp: Opcode = {
    "==" => Opcode::Eq,
    "!=" => Opcode::NotEq,
};

LessGreaterOp: Opcode = {
    "<" => Opcode::Lt,
    ">" => Opcode::Gt,
};
